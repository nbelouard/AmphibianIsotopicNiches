---
title: "Local isotopic niche partitioning and the coexistence between native amphibians and invasive crayfish #3: Compute niche metrics"
author: "Nadege Belouard"
date: "23/09/2022"
output:
  pdf_document:
    toc: yes
editor_options: 
  chunk_output_type: console
---

This vignette computes all isotopic niche metrics relative to populations and communities.
We first load the packages and the dataset.

```{r setup, warning = F, message = F}
library(siar)
library(SIBER)
library(dplyr)
library(spatstat.utils)
library(ggplot2)
library(here)
library(magrittr)
library(tidyr)
library(tibble)
library(reshape2)

```


```{r load datasets}

# Full dataset, with C1, crayfish and amphibians
Dataset <- read.csv(file.path(here(), "exported_data", 
                                       "Isotope_data_standardized.csv"), 
                    header=T)

head(Dataset)
dim(Dataset)
```


Table of the number of samples per pond
```{r number of samples}

table(Dataset$Pond, Dataset$Species)
```


Calculate the mean sample weight per taxa
```{r sample weights}

Dataset %>%
  group_by(Group) %>%
  summarise(meanweight = round(mean(Weight*1000),0), 
            sdweight = round(sd(Weight*1000),0))
```



# 1- Regional niche (per species over all ponds)

Select the appropriate species and get the average position of their regional niche.
```{r select appropriate species}

Subset_Dataset <- Dataset %>% dplyr::filter(!Group == "C1")

Subset_Dataset %>% group_by(Species) %>% 
  summarise(meanTP = mean(TP),
            meanD13C = mean(D13Ccor_consoI))

spx <- split(Subset_Dataset$D13Ccor_consoI, Subset_Dataset$Species, 
             drop = TRUE)
spy <- split(Subset_Dataset$TP, Subset_Dataset$Species, drop = TRUE)

```

## a- SEA coordinates
Generate the coordinates of the standard ellipses for each regional niche and export them.
```{r regional SEAc coordinates}

Species <- NULL
coordY <- NULL
coordX <- NULL
j = 1

for (i in 1:length(spx)) {
  SE <- siar::standard.ellipse(spx[[i]], spy[[i]], steps = 1)
  Species[j:(j+360)] <- names(spx)[i]
  coordY[j:(j+360)] <- SE$ySEAc[1:361]
  coordX[j:(j+360)] <- SE$xSEAc[1:361]
  j = j + 361
}

CoordSEAc <- cbind(Species, coordY, coordX)
summary(CoordSEAc)
CoordSEAc <- as.data.frame(CoordSEAc)
CoordSEAc$coordY <- as.numeric(as.character(CoordSEAc$coordY))
CoordSEAc$coordX <- as.numeric(as.character(CoordSEAc$coordX))
str(CoordSEAc)
head(CoordSEAc)

write.csv(CoordSEAc, file.path(here(), "exported_data", 
                               "Coordinates_SEAc_regional.csv"), row.names = F)
``` 

## b- Area of ellipses overlap for regional niches
```{r area of ellipses overlap}

#Initialize vectors
Species1 = NULL
Species2 = NULL
AreaOverlap = NULL
AreaSp1 = NULL
AreaSp2 = NULL
Table = data.frame()

# Run command: with crayfish
for (i in names(spx[c(1,3:5)])){
Overlap <- siar::overlap(spx$Crayfish, spy$Crayfish,
                         spx[[i]], spy[[i]], steps=1)
AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
Species1 <- append(Species1, "Crayfish", after = length(Species1))
Species2 <- append(Species2, names(spx[i]), after = length(Species2))
AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
} 
 
# Run command: with agile frog
for (i in names(spx[c(3:5)])){
Overlap <- siar::overlap(spx$`Agile frog`, spy$`Agile frog`,
                         spx[[i]], spy[[i]], steps=1)
AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
Species1 <- append(Species1, "Agile frog", after = length(Species1))
Species2 <- append(Species2, names(spx[i]), after = length(Species2))
AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
} 

# Run command: with marbled newt
for (i in names(spx[c(4:5)])){
Overlap <- siar::overlap(spx$`Marbled newt`, spy$`Marbled newt`,
                         spx[[i]], spy[[i]], steps=1)
AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
Species1 <- append(Species1, "Marbled newt", after = length(Species1))
Species2 <- append(Species2, names(spx[i]), after = length(Species2))
AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
}


# Run command: palmate newt/tree frog (the only one left)
Overlap <- siar::overlap(spx$`Palmate newt`, spy$`Palmate newt`,
                         spx$`Tree frog`, spy$`Tree frog`, steps=1)
AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
Species1 <- append(Species1, "Palmate newt", after = length(Species1))
Species2 <- append(Species2, "Tree frog", after = length(Species2))
AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))

```


Visualize regional overlaps and export them
``` {r analyses of overlaps}

Table <- cbind(Species1, Species2, AreaOverlap = round(AreaOverlap,4), 
             AreaSp1 = round(AreaSp1,4), AreaSp2 = round(AreaSp2,4))

Table <- as.data.frame(Table)
Table$Prct_overlap <- round(as.numeric(Table$AreaOverlap) / (as.numeric(Table$AreaSp1)+as.numeric(Table$AreaSp2)),4)
Table$Prct_overlap_sp2 <- round(as.numeric(Table$AreaOverlap) / as.numeric(Table$AreaSp2),4)
Table$Prct_overlap_sp1 <- round(as.numeric(Table$AreaOverlap) / as.numeric(Table$AreaSp1),4)
Table

write.csv(Table, file.path(here(), "exported_data", 
                           "Overlap_regional_niches.csv"), row.names = F)
```








# 2- Population metrics

We calculate population metrics for amphibians and crayfish.

We begin with selecting the species of interest and removing populations with inadequate samples sizes, i.e. large populations with n < 10. Some populations have n < 10 but are kept because we have good indicators from CMR that the sample size is representative of the population.

```{r select appropriate populations}

Subset_Dataset <- Dataset %>% dplyr::filter(!Group == "C1")

# We want to exclude target populations with n < 10, except three pops: marbled newt in ponds U04 and U06, and palmate newt in pop I08 where we assume we have sampled the entire population.
Subset_Dataset %>% group_by(Species, Pond) %>% summarise(n = n()) %>% 
  filter(n < 10)

Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Crayfish"|
                                 !Subset_Dataset$Pond == "I01",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Agile frog"|
                                 !Subset_Dataset$Pond=="I07",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Agile frog"|
                                 !Subset_Dataset$Pond=="U02",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Marbled newt"|
                                 !Subset_Dataset$Pond=="I08",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Marbled newt"|
                                 !Subset_Dataset$Pond=="I11",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Palmate newt"|
                                 !Subset_Dataset$Pond=="I05",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Palmate newt"|
                                 !Subset_Dataset$Pond== "I07",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Palmate newt"|
                                 !Subset_Dataset$Pond== "I09",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Palmate newt"|
                                 !Subset_Dataset$Pond=="I10",]
Subset_Dataset<-Subset_Dataset[!Subset_Dataset$Species=="Palmate newt"|
                                 !Subset_Dataset$Pond=="I13",]


table(Subset_Dataset$Pond, Subset_Dataset$Species)

# Separate per niche (species x pond)
spx <- split(Subset_Dataset$D13Ccor_consoI, 
             list(Subset_Dataset$Pond, Subset_Dataset$Species), drop = TRUE)
spy <- split(Subset_Dataset$TP, 
             list(Subset_Dataset$Pond, Subset_Dataset$Species), drop = TRUE)
```

Check if the number of populations is correct

```{r check number of individuals is correct}

dim(Subset_Dataset[Subset_Dataset$Taxa=="Agile frog",])[1] == 274 
dim(Subset_Dataset[Subset_Dataset$Taxa=="Tree frog",])[1] == 187
dim(Subset_Dataset[Subset_Dataset$Taxa=="Palmate newt",])[1] == 209
dim(Subset_Dataset[Subset_Dataset$Taxa=="Marbled newt",])[1] == 101
dim(Subset_Dataset[Subset_Dataset$Species=="Crayfish",])[1] == 422

```


## a- Layman metrics

We first calculate the six metrics of Layman (TA, CR, NR, CD, MNND, SDNND) on each population for each pond. This is done by providing a vector containing the list of populations and ponds.

```{r calculate Layman metrics for populations}

Table <- data.frame(metrics = c("dX_range", "dY_range", "NND", "SDNND", 
                                "CD", "TA"))

for (i in 1:length(spx)) {  
  Metrics <- laymanMetrics(spx[[i]],spy[[i]])
  Data <- as.data.frame(Metrics$metrics)
  Data$metrics <- rownames(Data)
  colnames(Data)[1] <- names(spx[i])
  Table <- merge(Table, Data, by = 'metrics', suffixes = colnames(Data)[1], 
                 all = TRUE)
}

Pop_metrics_Layman <- as.data.frame(t(Table))
colnames(Pop_metrics_Layman) <- Pop_metrics_Layman[1,]
Pop_metrics_Layman <- Pop_metrics_Layman[-1,]
Pop_metrics_Layman$Code <- rownames(Pop_metrics_Layman)


```


## b- Layman metrics with bootstrapping
Now we calculate the equivalent using the bootstrapping method. For each pop, we sample 10 individuals in the population, calculate the 6 metrics of Layman, then do it again 999 times.

```{r calculate Layman metrics with bootstrapping for populations, include=FALSE}

# Make sure we find the same results everytime by setting the seed
set.seed(10)

# We group samples by pond and species again
spx <- split(Subset_Dataset$D13Ccor_consoI, 
             list(Subset_Dataset$Pond, Subset_Dataset$Species), drop = TRUE)
spy <- split(Subset_Dataset$TP, 
             list(Subset_Dataset$Pond, Subset_Dataset$Species), drop = TRUE)


# Number of bootstrapped required
nr <- 9999 # the number of reps
ncol = 57

# Create empty vectors to store the results 
dNR <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
dCR <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
TA <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
CD <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
MNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
SDNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))

names(dNR) <- names(spx)
names(dCR) <- names(spx)
names(TA) <- names(spx)
names(CD) <- names(spx)
names(MNND) <- names(spx)
names(SDNND) <- names(spx)

for (j in 1:length(spx)) {
  if (length(spx[[j]]) > 10) {
    for (i in 1:nr) {
      simX<-sample(spx[[j]], 10, replace = FALSE, prob = NULL)
      simY<-sample(spy[[j]],10,replace = FALSE,prob=NULL)
      layman <- laymanmetrics(simX, simY)
      dNR[i,j] <- layman$dN_range
      dCR[i,j] <- layman$dC_range
      TA[i,j] <- layman$hull$TA
      CD[i,j] <- layman$CD
      MNND[i,j] <- layman$MNND
      SDNND[i,j] <- layman$SDNND
    }
    }
  }


```


```{r calculate average bootstrapped Layman metrics for populations, include=FALSE}

Pop_metrics_bootstrapped <- as.data.frame(cbind(NRb = colMeans(dNR), 
                                  CRb = colMeans(dCR), 
                                  TAb = colMeans(TA),
                                  CDb = colMeans(CD), 
                                  MNNDb = colMeans(MNND), 
                                  SDNNDb = colMeans(SDNND),
                                  Code = colnames(dNR)))

```

## c- SEA metrics
Finally, we calculate TA, SEA and SEAc for populations from Layman. 

```{r calculate population ellipses, include=FALSE}

Subset_Dataset_ellipses <- Subset_Dataset %>% 
  dplyr::select("iso1" = D13Ccor_consoI, "iso2" = TP, "group" = Species, 
                "community" = Pond) %>%
  as.data.frame()

Subset_Dataset_SIBER <- createSiberObject(Subset_Dataset_ellipses)
Pop_metrics_SEAc <- groupMetricsML(Subset_Dataset_SIBER)

#Table transformation
Pop_metrics_ellipses <- as.data.frame(t(Pop_metrics_SEAc))
Pop_metrics_ellipses$Code <- rownames(Pop_metrics_ellipses)
Pop_metrics_ellipses$Pond <- gsub("[.].*","",Pop_metrics_ellipses$Code)
Pop_metrics_ellipses$Species <- gsub(".*.[.]","",Pop_metrics_ellipses$Code)

```


## d- Merge datasets
Finally, we merge the three datasets.


```{r merge datasets, include=FALSE}

Pop_metrics <- merge(Pop_metrics_Layman, Pop_metrics_bootstrapped, by = "Code")
dim(Pop_metrics)

#Create a composite metric to avoid NAs in bootstrapped metrics
Pop_metrics$NRcp = Pop_metrics$NRb 
Pop_metrics$CRcp = Pop_metrics$CRb
Pop_metrics$TAcp = Pop_metrics$TAb
Pop_metrics$CDcp = Pop_metrics$CDb
Pop_metrics$MNNDcp = Pop_metrics$MNNDb
Pop_metrics$SDNNDcp = Pop_metrics$SDNNDb

for (i in 1:length(Pop_metrics$NRb)) {
  if (is.na(Pop_metrics$NRb[i]) == TRUE) {
    Pop_metrics$NRcp[i] <- Pop_metrics$dY_range[i]
    Pop_metrics$CRcp[i] <- Pop_metrics$dX_range[i]
    Pop_metrics$TAcp[i] <- Pop_metrics$TA[i]
    Pop_metrics$CDcp[i] <- Pop_metrics$CD[i]
    Pop_metrics$MNNDcp[i] <- Pop_metrics$NND[i]
    Pop_metrics$SDNNDcp[i] <- Pop_metrics$SDNND[i]
  }
}

Pop_metrics <- merge(Pop_metrics, Pop_metrics_ellipses[-1], by = "Code")


ggplot(aes(x = as.numeric(CRcp), y = as.numeric(dX_range)), 
       data = Pop_metrics) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1)


ggplot(aes(x = as.numeric(NRcp), y = as.numeric(dY_range)), 
       data = Pop_metrics) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1)


write.csv(Pop_metrics, 
          file.path(here(), "exported_data", "Population_metrics.csv"), 
          row.names = F)
```


## e- SEA coordinates 

```{r population SEAc coordinates, include=FALSE}

Pop <- NULL
coordY <- NULL
coordX <- NULL
j = 1

for (i in 1:length(spx)) {
  SE <- standard.ellipse(spx[[i]],spy[[i]],steps=1)
  Pop[j:(j+360)]<-names(spx)[i]
  coordY[j:(j+360)]<-SE$ySEAc[1:361]
  coordX[j:(j+360)]<-SE$xSEAc[1:361]
  j=j+361
}

CoordSEAc <- cbind(Pop,coordY,coordX)
summary(CoordSEAc)
CoordSEAc <- as.data.frame(CoordSEAc)
CoordSEAc$coordY <- as.numeric(as.character(CoordSEAc$coordY))
CoordSEAc$coordX <- as.numeric(as.character(CoordSEAc$coordX))
str(CoordSEAc)
CoordSEAc$Pond <- gsub("\\..*","",CoordSEAc$Pop)
CoordSEAc$Species <- gsub(".*\\.","",CoordSEAc$Pop)
head(CoordSEAc)
CoordSEAc$Pond <- as.factor(CoordSEAc$Pond)
levels(CoordSEAc$Pond)

write.csv(CoordSEAc, 
          file.path(here(), "exported_data", "Coordinates_SEAc_populations.csv"), 
          row.names = F)
``` 


```{r centroides of standard ellipses}

CoordSEAc <- read.csv(file.path(here(), "exported_data",
                                "Coordinates_SEAc_populations.csv"), header=T)

Mean_position <- CoordSEAc %>% group_by(Pond, Species, Pop) %>%
  summarise(TPavg = mean(coordY),
            D13Cavg = mean(coordX))

write.csv(Mean_position, file.path(here(), "exported_data", 
                                   "Meanposition_SEAc.csv"), row.names = F)

```




## f- Area of ellipses overlap

````{r area of ellipses overlap: initialize vectors}

#Split dataset by species
Crayfish <- Subset_Dataset %>% filter(Species == "Crayfish")
Treefrog <- Subset_Dataset[Subset_Dataset$Taxa == "Tree frog",] 
Agilefrog <- Subset_Dataset[Subset_Dataset$Taxa == "Agile frog",] 
Palmatenewt <- Subset_Dataset[Subset_Dataset$Taxa == "Palmate newt",] 
Marblednewt <- Subset_Dataset[Subset_Dataset$Taxa == "Marbled newt",] 


#For each species, split dataset by pond
spx_Agilefrog <- split(Agilefrog$D13Ccor_consoI, list(Agilefrog$Pond), 
                       drop = FALSE)
spy_Agilefrog <- split(Agilefrog$TP, list(Agilefrog$Pond), 
                       drop = FALSE)
spx_Treefrog <- split(Treefrog$D13Ccor_consoI, list(Treefrog$Pond), 
                       drop = FALSE)
spy_Treefrog <- split(Treefrog$TP, list(Treefrog$Pond), 
                       drop = FALSE)
spx_Palmatenewt <- split(Palmatenewt$D13Ccor_consoI, list(Palmatenewt$Pond), 
                       drop = FALSE)
spy_Palmatenewt <- split(Palmatenewt$TP, list(Palmatenewt$Pond), 
                       drop = FALSE)
spx_Marblednewt <- split(Marblednewt$D13Ccor_consoI, list(Marblednewt$Pond), 
                       drop = FALSE)
spy_Marblednewt <- split(Marblednewt$TP, list(Marblednewt$Pond), 
                       drop = FALSE)
spx_Crayfish <- split(Crayfish$D13Ccor_consoI, list(Crayfish$Pond), 
                       drop = FALSE)
spy_Crayfish <- split(Crayfish$TP, list(Crayfish$Pond), 
                       drop = FALSE)

#Initialize vectors
Pond = NULL
Species1 = NULL
Species2 = NULL
AreaOverlap = NULL
AreaSp1 = NULL
AreaSp2 = NULL
Table = data.frame()
```

## All crayfish
```{r loop over all crayfish}

for (i in names(spx_Crayfish)) {
  if (length(spx_Agilefrog[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Crayfish", after = length(Species1))
    Species2 <- append(Species2, "Agile frog", after = length(Species2))
    Overlap <- siar::overlap(spx_Crayfish[[i]], spy_Crayfish[[i]],
                             spx_Agilefrog[[i]], spy_Agilefrog[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
  
  if (length(spx_Treefrog[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Crayfish", after = length(Species1))
    Species2 <- append(Species2, "Tree frog", after = length(Species2))
    Overlap <- siar::overlap(spx_Crayfish[[i]], spy_Crayfish[[i]],
                             spx_Treefrog[[i]], spy_Treefrog[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
  
  if (length(spx_Palmatenewt[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Crayfish", after = length(Species1))
    Species2 <- append(Species2, "Palmate newt", after = length(Species2))
    Overlap <- siar::overlap(spx_Crayfish[[i]], spy_Crayfish[[i]],
                             spx_Palmatenewt[[i]], spy_Palmatenewt[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
  
  if (length(spx_Marblednewt[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Crayfish", after = length(Species1))
    Species2 <- append(Species2, "Marbled newt", after = length(Species2))
    Overlap <- siar::overlap(spx_Crayfish[[i]], spy_Crayfish[[i]],
                             spx_Marblednewt[[i]], spy_Marblednewt[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
}
```

## Between amphibians
```{r area of ellipses overlap: loop between amphibians}

for (i in names(spx_Agilefrog)) {
  if (length(spx_Treefrog[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Agile frog", after = length(Species1))
    Species2 <- append(Species2, "Tree frog", after = length(Species2))
    Overlap <- siar::overlap(spx_Agilefrog[[i]], spy_Agilefrog[[i]],
                             spx_Treefrog[[i]], spy_Treefrog[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
  
  if (length(spx_Palmatenewt[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Agile frog", after = length(Species1))
    Species2 <- append(Species2, "Palmate newt", after = length(Species2))
    Overlap <- siar::overlap(spx_Agilefrog[[i]], spy_Agilefrog[[i]],
                             spx_Palmatenewt[[i]], spy_Palmatenewt[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
  
  if (length(spx_Marblednewt[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Agile frog", after = length(Species1))
    Species2 <- append(Species2, "Marbled newt", after = length(Species2))
    Overlap <- siar::overlap(spx_Agilefrog[[i]], spy_Agilefrog[[i]],
                             spx_Marblednewt[[i]], spy_Marblednewt[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
}



for (i in names(spx_Treefrog)) {
  if (length(spx_Palmatenewt[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Tree frog", after = length(Species1))
    Species2 <- append(Species2, "Palmate newt", after = length(Species2))
    Overlap <- siar::overlap(spx_Treefrog[[i]], spy_Treefrog[[i]],
                             spx_Palmatenewt[[i]], spy_Palmatenewt[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
  
  if (length(spx_Marblednewt[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Tree frog", after = length(Species1))
    Species2 <- append(Species2, "Marbled newt", after = length(Species2))
    Overlap <- siar::overlap(spx_Treefrog[[i]], spy_Treefrog[[i]],
                             spx_Marblednewt[[i]], spy_Marblednewt[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
}


for (i in names(spx_Palmatenewt)) {
  if (length(spx_Marblednewt[[i]]) != 0) {
    Pond <- append(Pond, i, after = length(Pond))
    Species1 <- append(Species1, "Palmate newt", after = length(Species1))
    Species2 <- append(Species2, "Marbled newt", after = length(Species2))
    Overlap <- siar::overlap(spx_Palmatenewt[[i]], spy_Palmatenewt[[i]],
                             spx_Marblednewt[[i]], spy_Marblednewt[[i]], steps=1)
    AreaOverlap <- append(AreaOverlap, Overlap$overlap, after = length(AreaOverlap))
    AreaSp1 <- append(AreaSp1, Overlap$area1, after = length(AreaSp1))
    AreaSp2 <- append(AreaSp2, Overlap$area2, after = length(AreaSp2))
  }
}

```


## Analyses of overlap areas

``` {r analyses of overlaps}

Table <- cbind(Pond, Species1, Species2, AreaOverlap = round(AreaOverlap,4), 
             AreaSp1 = round(AreaSp1,4), AreaSp2 = round(AreaSp2,4))

Table <- as.data.frame(Table)
Table$Prct_overlap <- round(as.numeric(Table$AreaOverlap) / (as.numeric(Table$AreaSp1)+as.numeric(Table$AreaSp2)),4)
Table$Prct_overlap_sp2 <- round(as.numeric(Table$AreaOverlap) / as.numeric(Table$AreaSp2),4)
Table$Prct_overlap_sp1 <- round(as.numeric(Table$AreaOverlap) / as.numeric(Table$AreaSp1),4)
Table

# COMMENT THIS LINE AND UNCOMMENT THE NEXT ONE FOR THE COMPLETE DATASET
write.csv(Table, file.path(here(), "exported_data", "Overlap_populations.csv"), 
          row.names = F)

```


```{r generate the long version of this table for Supp Mat}

Pop_metrics <- read.csv(file.path(here(), "exported_data", 
                                  "Population_metrics.csv"))

Mean_position <- read.csv(file.path(here(), "exported_data", 
                                    "Meanposition_SEAc.csv"))

names(Mean_position)[3] = "Code"
Mean_position %<>% select(-Pond, -Species) 
Pop_metrics <- merge(Pop_metrics, Mean_position, by = "Code")
Pop_metrics %<>% select(Pond, Species, CRcp, NRcp, TAcp, CDcp, MNNDcp, SDNNDcp, SEAc, TPavg, D13Cavg)

Pop_metrics_long <- rbind(Pop_metrics %>% dcast(Pond ~ Species, value.var = "CRcp") %>% add_column(Metrics = "CRcp"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "NRcp") %>% add_column(Metrics = "NRcp"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "TAcp") %>% add_column(Metrics = "TAcp"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "CDcp") %>% add_column(Metrics = "CDcp"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "MNNDcp") %>% add_column(Metrics = "MNNDcp"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "SDNNDcp") %>% add_column(Metrics = "SDNNDcp"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "SEAc") %>% add_column(Metrics = "SEAc"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "TPavg") %>% add_column(Metrics = "TPavg"),
      Pop_metrics %>% dcast(Pond ~ Species, value.var = "D13Cavg") %>% add_column(Metrics = "D13Cavg"))
      

write.csv(Pop_metrics_long, file.path(here(), "exported_data", "Population_metrics_long.csv"), row.names = F)
```


# 3- Calculate CD between populations and global species niche
Calculate Layman metrics - Agile frog pop vs global
```{r calculate Layman metrics for agile frog}

# Select agile frog
Agile_dataset <- Subset_Dataset %>% filter(Species == "Agile frog")

# Create ponds
spx <- split(Agile_dataset$D13Ccor_consoI, Agile_dataset$Pond, drop = TRUE)
spy <- split(Agile_dataset$TP, Agile_dataset$Pond, drop = TRUE)

Table <- data.frame(metrics = c("dX_range", "dY_range", "NND", "SDNND", "CD", "TA"))

for (i in 1:length(spx)) {  
  Metrics <- laymanMetrics(spx[[i]],spy[[i]])
  Data <- as.data.frame(Metrics$metrics)
  Data$metrics <- rownames(Data)
  colnames(Data)[1] <- names(spx[i])
  Table <- merge(Table, Data, by = 'metrics', suffixes = colnames(Data)[1], all=TRUE)
}

Layman_agile <- as.data.frame(t(Table))
colnames(Layman_agile) <- Layman_agile[1,]
Layman_agile <- Layman_agile[-1,]
Layman_agile$Code <- rownames(Layman_agile)
Layman_agile %<>% mutate(Species = "Agile frog") 

```

Calculate Layman metrics - Tree frog pop vs global
```{r calculate Layman metrics for tree frog}

# Select 
Treefrog_dataset <- Subset_Dataset %>% filter(Species == "Tree frog")

# Create ponds
spx <- split(Treefrog_dataset$D13Ccor_consoI, Treefrog_dataset$Pond, drop = TRUE)
spy <- split(Treefrog_dataset$TP, Treefrog_dataset$Pond, drop = TRUE)

Table <- data.frame(metrics = c("dX_range", "dY_range", "NND", "SDNND", "CD", "TA"))

for (i in 1:length(spx)) {  
  Metrics <- laymanMetrics(spx[[i]],spy[[i]])
  Data <- as.data.frame(Metrics$metrics)
  Data$metrics <- rownames(Data)
  colnames(Data)[1] <- names(spx[i])
  Table <- merge(Table, Data, by = 'metrics', suffixes = colnames(Data)[1], all=TRUE)
}

Layman_treefrog <- as.data.frame(t(Table))
colnames(Layman_treefrog) <- Layman_treefrog[1,]
Layman_treefrog <- Layman_treefrog[-1,]
Layman_treefrog$Code <- rownames(Layman_treefrog)
Layman_treefrog %<>% mutate(Species = "Tree frog") 
```

Calculate Layman metrics - Palmate newt pop vs global
```{r calculate Layman metrics for palmate newt}

# Select 
Palmate_dataset <- Subset_Dataset %>% filter(Species == "Palmate newt")

# Create ponds
spx <- split(Palmate_dataset$D13Ccor_consoI, Palmate_dataset$Pond, drop = TRUE)
spy <- split(Palmate_dataset$TP, Palmate_dataset$Pond, drop = TRUE)

Table <- data.frame(metrics = c("dX_range", "dY_range", "NND", "SDNND", "CD", "TA"))

for (i in 1:length(spx)) {  
  Metrics <- laymanMetrics(spx[[i]],spy[[i]])
  Data <- as.data.frame(Metrics$metrics)
  Data$metrics <- rownames(Data)
  colnames(Data)[1] <- names(spx[i])
  Table <- merge(Table, Data, by = 'metrics', suffixes = colnames(Data)[1], all=TRUE)
}

Layman_palmate <- as.data.frame(t(Table))
colnames(Layman_palmate) <- Layman_palmate[1,]
Layman_palmate <- Layman_palmate[-1,]
Layman_palmate$Code <- rownames(Layman_palmate)
Layman_palmate %<>% mutate(Species = "Palmate newt") 
```

Calculate Layman metrics - Palmate newt pop vs global
```{r calculate Layman metrics for palmate newt}

# Select
Marbled_dataset <- Subset_Dataset %>% filter(Species == "Marbled newt")

# Create ponds
spx <- split(Marbled_dataset$D13Ccor_consoI, Marbled_dataset$Pond, drop = TRUE)
spy <- split(Marbled_dataset$TP, Marbled_dataset$Pond, drop = TRUE)

Table <- data.frame(metrics = c("dX_range", "dY_range", "NND", "SDNND", "CD", "TA"))

for (i in 1:length(spx)) {  
  Metrics <- laymanMetrics(spx[[i]],spy[[i]])
  Data <- as.data.frame(Metrics$metrics)
  Data$metrics <- rownames(Data)
  colnames(Data)[1] <- names(spx[i])
  Table <- merge(Table, Data, by = 'metrics', suffixes = colnames(Data)[1], all=TRUE)
}

Layman_marbled <- as.data.frame(t(Table))
colnames(Layman_marbled) <- Layman_marbled[1,]
Layman_marbled <- Layman_marbled[-1,]
Layman_marbled$Code <- rownames(Layman_marbled)
Layman_marbled %<>% mutate(Species = "Marbled newt") 
```

Calculate Layman metrics - crayfish pop vs global
```{r calculate Layman metrics for crayfish}

# Select
Crayfish_dataset <- Subset_Dataset %>% filter(Species == "Crayfish")

# Create ponds
spx <- split(Crayfish_dataset$D13Ccor_consoI, Crayfish_dataset$Pond, drop = TRUE)
spy <- split(Crayfish_dataset$TP, Crayfish_dataset$Pond, drop = TRUE)

Table <- data.frame(metrics = c("dX_range", "dY_range", "NND", "SDNND", "CD", "TA"))

for (i in 1:length(spx)) {  
  Metrics <- laymanMetrics(spx[[i]],spy[[i]])
  Data <- as.data.frame(Metrics$metrics)
  Data$metrics <- rownames(Data)
  colnames(Data)[1] <- names(spx[i])
  Table <- merge(Table, Data, by = 'metrics', suffixes = colnames(Data)[1], all=TRUE)
}

Layman_crayfish <- as.data.frame(t(Table))
colnames(Layman_crayfish) <- Layman_crayfish[1,]
Layman_crayfish <- Layman_crayfish[-1,]
Layman_crayfish$Code <- rownames(Layman_crayfish)
Layman_crayfish %<>% mutate(Species = "Crayfish") 

```


## Bootstrapped version
Now we calculate the equivalent using the bootstrapping method. For each pop, we sample 10 individuals in the population, calculate the 6 metrics of Layman, then do it again 999 times.

Agile frog
```{r calculate Layman metrics with bootstrapping for agile frog}

# Make sure we find the same results everytime by setting the seed
set.seed(10)

# We group samples by pond and species again
spx <- split(Agile_dataset$D13Ccor_consoI, 
             Agile_dataset$Pond, drop = TRUE)
spy <- split(Agile_dataset$TP,
             Agile_dataset$Pond, drop = TRUE)

# Number of bootstrapped required
nr <- 9999 # the number of reps
ncol = length(spy)

# Create empty vectors to store the results 
CD <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
MNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
SDNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))

names(CD)<-names(spx)
names(MNND)<-names(spx)
names(SDNND)<-names(spx)

for (j in 1:length(spx)) {
  if (length(spx[[j]]) > 10) {
    for (i in 1:nr) {
      simX<-sample(spx[[j]], 10, replace = FALSE, prob = NULL)
      simY<-sample(spy[[j]],10,replace = FALSE,prob=NULL)
      layman <- laymanmetrics(simX, simY)
      CD[i,j] <- layman$CD
      MNND[i,j] <- layman$MNND
      SDNND[i,j] <- layman$SDNND
    }
    }
}

Agile_bootstrapped <- as.data.frame(cbind(
                                  CDb = colMeans(CD), 
                                  MNNDb = colMeans(MNND), 
                                  SDNNDb = colMeans(SDNND),
                                  Code = colnames(CD)))

```

Tree frog
```{r calculate Layman metrics with bootstrapping for tree frog}

# Make sure we find the same results everytime by setting the seed
set.seed(10)

# We group samples by pond and species again
spx <- split(Treefrog_dataset$D13Ccor_consoI, 
             Treefrog_dataset$Pond, drop = TRUE)
spy <- split(Treefrog_dataset$TP,
             Treefrog_dataset$Pond, drop = TRUE)

# Number of bootstrapped required
nr <- 9999 # the number of reps
ncol = length(spy)

# Create empty vectors to store the results 
CD <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
MNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
SDNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))

names(CD)<-names(spx)
names(MNND)<-names(spx)
names(SDNND)<-names(spx)

for (j in 1:length(spx)) {
  if (length(spx[[j]]) > 10) {
    for (i in 1:nr) {
      simX<-sample(spx[[j]], 10, replace = FALSE, prob = NULL)
      simY<-sample(spy[[j]],10,replace = FALSE,prob=NULL)
      layman <- laymanmetrics(simX, simY)
      CD[i,j] <- layman$CD
      MNND[i,j] <- layman$MNND
      SDNND[i,j] <- layman$SDNND
    }
    }
}

Treefrog_bootstrapped <- as.data.frame(cbind(
                                  CDb = colMeans(CD), 
                                  MNNDb = colMeans(MNND), 
                                  SDNNDb = colMeans(SDNND),
                                  Code = colnames(CD)))

```

Palmate newt
```{r calculate Layman metrics with bootstrapping for palmate newt}

# Make sure we find the same results everytime by setting the seed
set.seed(10)

# We group samples by pond and species again
spx <- split(Palmate_dataset$D13Ccor_consoI, 
             Palmate_dataset$Pond, drop = TRUE)
spy <- split(Palmate_dataset$TP,
             Palmate_dataset$Pond, drop = TRUE)

# Number of bootstrapped required
nr <- 9999 # the number of reps
ncol = length(spy)

# Create empty vectors to store the results 
CD <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
MNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
SDNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))

names(CD)<-names(spx)
names(MNND)<-names(spx)
names(SDNND)<-names(spx)

for (j in 1:length(spx)) {
  if (length(spx[[j]]) > 10) {
    for (i in 1:nr) {
      simX<-sample(spx[[j]], 10, replace = FALSE, prob = NULL)
      simY<-sample(spy[[j]],10,replace = FALSE,prob=NULL)
      layman <- laymanmetrics(simX, simY)
      CD[i,j] <- layman$CD
      MNND[i,j] <- layman$MNND
      SDNND[i,j] <- layman$SDNND
    }
    }
}

Palmate_bootstrapped <- as.data.frame(cbind(
                                  CDb = colMeans(CD), 
                                  MNNDb = colMeans(MNND), 
                                  SDNNDb = colMeans(SDNND),
                                  Code = colnames(CD)))

```

Marbled newt
```{r calculate Layman metrics with bootstrapping for marbled newt}

# Make sure we find the same results everytime by setting the seed
set.seed(10)

# We group samples by pond and species again
spx <- split(Marbled_dataset$D13Ccor_consoI, 
             Marbled_dataset$Pond, drop = TRUE)
spy <- split(Marbled_dataset$TP,
             Marbled_dataset$Pond, drop = TRUE)

# Number of bootstrapped required
nr <- 9999 # the number of reps
ncol = length(spy)

# Create empty vectors to store the results 
CD <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
MNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
SDNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))

names(CD)<-names(spx)
names(MNND)<-names(spx)
names(SDNND)<-names(spx)

for (j in 1:length(spx)) {
  if (length(spx[[j]]) > 10) {
    for (i in 1:nr) {
      simX<-sample(spx[[j]], 10, replace = FALSE, prob = NULL)
      simY<-sample(spy[[j]],10,replace = FALSE,prob=NULL)
      layman <- laymanmetrics(simX, simY)
      CD[i,j] <- layman$CD
      MNND[i,j] <- layman$MNND
      SDNND[i,j] <- layman$SDNND
    }
    }
}

Marbled_bootstrapped <- as.data.frame(cbind(
                                  CDb = colMeans(CD), 
                                  MNNDb = colMeans(MNND), 
                                  SDNNDb = colMeans(SDNND),
                                  Code = colnames(CD)))

```

Crayfish
```{r calculate Layman metrics with bootstrapping for crayfish}

# Make sure we find the same results everytime by setting the seed
set.seed(10)

# We group samples by pond and species again
spx <- split(Crayfish_dataset$D13Ccor_consoI, 
             Crayfish_dataset$Pond, drop = TRUE)
spy <- split(Crayfish_dataset$TP,
             Crayfish_dataset$Pond, drop = TRUE)

# Number of bootstrapped required
nr <- 9999 # the number of reps
ncol = length(spy)

# Create empty vectors to store the results 
CD <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
MNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))
SDNND <- data.frame(matrix(NA, ncol = ncol, nrow = nr))

names(CD)<-names(spx)
names(MNND)<-names(spx)
names(SDNND)<-names(spx)

for (j in 1:length(spx)) {
  if (length(spx[[j]]) > 10) {
    for (i in 1:nr) {
      simX<-sample(spx[[j]], 10, replace = FALSE, prob = NULL)
      simY<-sample(spy[[j]],10,replace = FALSE,prob=NULL)
      layman <- laymanmetrics(simX, simY)
      CD[i,j] <- layman$CD
      MNND[i,j] <- layman$MNND
      SDNND[i,j] <- layman$SDNND
    }
    }
}

Crayfish_bootstrapped <- as.data.frame(cbind(
                                  CDb = colMeans(CD), 
                                  MNNDb = colMeans(MNND), 
                                  SDNNDb = colMeans(SDNND),
                                  Code = colnames(CD)))

```


## Merge all datasets
```{r merge CD tables to create CDcp}

CD_global <- rbind(
  merge(Layman_agile %>% dplyr::select(Code, CD, NND, SDNND, Species), 
        Agile_bootstrapped, by = "Code"),
  merge(Layman_treefrog %>% dplyr::select(Code, CD, NND, SDNND, Species), 
        Treefrog_bootstrapped, by = "Code"),
  merge(Layman_palmate %>% dplyr::select(Code, CD, NND, SDNND, Species), 
        Palmate_bootstrapped, by = "Code"),
  merge(Layman_marbled %>% dplyr::select(Code, CD, NND, SDNND, Species), 
        Marbled_bootstrapped, by = "Code"),
  merge(Layman_crayfish %>% dplyr::select(Code, CD, NND, SDNND, Species), 
        Crayfish_bootstrapped, by = "Code")
)

#Create a composite metric to avoid NAs in bootstrapped metrics
CD_global %<>% mutate(CDcp = CDb,
                      MNNDcp = MNNDb,
                      SDNNDcp = SDNNDb)


for (i in 1:length(CD_global$CDb)) {
  if (is.na(CD_global$CDb[i]) == TRUE) {
    CD_global$CDcp[i] <- CD_global$CD[i]
    CD_global$MNNDcp[i] <- CD_global$NND[i]
    CD_global$SDNNDcp[i] <- CD_global$SDNND[i]
  }
}

CD_global

write.csv(CD_global, file.path(here(), "exported_data", "CD_global.csv"), row.names = F)
```



